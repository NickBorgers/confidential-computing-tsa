name: Claude Code Review

# Dynamic run name shows PR number for easy identification in the Actions UI
# Format: "Claude Code Review (PR #123)" or "Claude Code Review (branch-name)"
run-name: >-
  ${{ github.event_name == 'workflow_dispatch' && format('Claude Code Review (PR #{0})', inputs.pr_number) ||
      github.event_name == 'pull_request' && format('Claude Code Review (PR #{0})', github.event.pull_request.number) ||
      format('Claude Code Review ({0})', github.event.workflow_run.head_branch) }}

# SECURITY NOTE: This workflow grants Claude Code access to secrets and write permissions.
# Authorization checks are implemented to prevent prompt injection and code execution from untrusted users.
# - Only PRs from repository collaborators, members, and owners trigger Claude reviews
# - The devcontainer is NEVER rebuilt from PR branches to prevent malicious Dockerfile injection
# - External PRs (from forks) are blocked from triggering Claude
#
# ARCHITECTURE: This workflow uses Claude Code Agent Teams to run all review
# agents in parallel within a single session. The team lead coordinates 7
# specialist reviewer teammates and synthesizes a merge decision.
#
# Previous architecture used 7 sequential reusable workflow calls (one per
# reviewer), each booting a separate devcontainer. Agent teams consolidate
# this into a single devcontainer with parallel review teammates.
#
# Individual review workflow files are retained for reference but no longer
# called by this orchestrator:
#   review-design.yml         - Design & intent validation
#   review-code-content.yml   - Code quality & documentation accuracy
#   review-test.yml           - Test coverage & quality (Rust only)
#   review-crypto.yml         - Cryptographic design validation
#   review-docs.yml           - Documentation completeness
#   review-standards.yml      - External reviewability & operator independence
#   review-rfc-standards.yml  - RFC 3161 / NIST PQC / AMD SEV-SNP compliance

on:
  workflow_run:
    workflows: ["PR Tests"]
    types: [completed]
  # Reset reviews when PR is reopened (allows re-triggering full review cycle)
  pull_request:
    types: [reopened]
  # Allow manual triggering after workflow_dispatch-triggered PR Tests completes
  # (workflow_run events don't fire for workflow_dispatch triggers)
  workflow_dispatch:
    inputs:
      head_ref:
        description: 'PR branch name'
        required: true
        type: string
      head_repo:
        description: 'PR repository (owner/repo format)'
        required: true
        type: string
      pr_number:
        description: 'PR number'
        required: true
        type: string
      tests_passed:
        description: 'Whether tests passed (true/false)'
        required: true
        type: string
      run_id:
        description: 'PR Tests workflow run ID'
        required: true
        type: string

# Prevent duplicate reviews when multiple PR Tests complete around the same time
concurrency:
  group: claude-review-${{ github.event_name == 'workflow_dispatch' && inputs.head_ref || github.event_name == 'pull_request' && github.event.pull_request.head.ref || github.event.workflow_run.head_branch }}
  cancel-in-progress: false

env:
  DEVCONTAINER_IMAGE: ghcr.io/nickborgers/confidential-computing-tsa-devcontainer

jobs:
  # ─── Context & Security ────────────────────────────────────────────────

  get-context:
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.get-pr.outputs.pr_number }}
      pr_title: ${{ steps.get-pr.outputs.pr_title }}
      pr_body_b64: ${{ steps.get-pr.outputs.pr_body_b64 }}
      head_ref: ${{ steps.get-pr.outputs.head_ref }}
      head_repo: ${{ steps.get-pr.outputs.head_repo }}
      is_draft: ${{ steps.get-pr.outputs.is_draft }}
      tests_passed: ${{ github.event_name == 'workflow_dispatch' && inputs.tests_passed == 'true' || github.event_name == 'pull_request' && 'false' || github.event.workflow_run.conclusion == 'success' }}
      run_id: ${{ github.event_name == 'workflow_dispatch' && inputs.run_id || github.event_name == 'pull_request' && github.run_id || github.event.workflow_run.id }}
      triggering_sha: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || github.event.workflow_run.head_sha }}
      issue_number: ${{ steps.get-issue.outputs.issue_number }}
      issue_title: ${{ steps.get-issue.outputs.issue_title }}
      issue_body_b64: ${{ steps.get-issue.outputs.issue_body_b64 }}
      fix_attempts: ${{ steps.count-attempts.outputs.count }}
      reviews_already_passed: ${{ steps.check-existing-reviews.outputs.already_passed }}
      author_authorized: ${{ steps.check-author-auth.outputs.authorized }}
      config_only: ${{ steps.classify-files.outputs.config_only }}
      has_rust_code: ${{ steps.classify-files.outputs.has_rust_code }}
      has_docs: ${{ steps.classify-files.outputs.has_docs }}

    steps:
      - name: Get PR from workflow run or dispatch inputs
        uses: actions/github-script@v7
        id: get-pr
        with:
          script: |
            const eventName = context.eventName;
            let headBranch, headRepo, prNumber;

            if (eventName === 'workflow_dispatch') {
              headBranch = '${{ inputs.head_ref }}';
              headRepo = '${{ inputs.head_repo }}';
              prNumber = parseInt('${{ inputs.pr_number }}', 10);
              console.log(`Triggered via workflow_dispatch for PR #${prNumber}`);
            } else if (eventName === 'pull_request') {
              const pr = context.payload.pull_request;
              headBranch = pr.head.ref;
              headRepo = pr.head.repo.full_name;
              prNumber = pr.number;
              console.log(`Triggered via pull_request event for PR #${prNumber}`);
            } else {
              headBranch = context.payload.workflow_run.head_branch;
              headRepo = context.payload.workflow_run.head_repository.full_name;
              console.log(`Looking for PR with head branch: ${headBranch} from ${headRepo}`);
            }

            let pr;
            if (prNumber) {
              const prResponse = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              pr = prResponse.data;
            } else {
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${headRepo.split('/')[0]}:${headBranch}`
              });
              if (prs.data.length > 0) {
                pr = prs.data[0];
              }
            }

            if (pr) {
              console.log(`Found PR #${pr.number}: ${pr.title}`);
              core.setOutput('pr_number', pr.number);
              core.setOutput('pr_title', pr.title);
              const prBodyB64 = Buffer.from(pr.body || '').toString('base64');
              core.setOutput('pr_body_b64', prBodyB64);
              core.setOutput('head_ref', pr.head.ref);
              core.setOutput('head_repo', pr.head.repo.full_name);
              core.setOutput('is_draft', pr.draft ? 'true' : 'false');
            } else {
              console.log('No open PR found for this workflow run');
              core.setOutput('pr_number', '');
              core.setOutput('is_draft', 'false');
            }

      - name: Extract linked issue from PR body
        if: steps.get-pr.outputs.pr_number != ''
        id: get-issue
        env:
          PR_BODY_B64: ${{ steps.get-pr.outputs.pr_body_b64 }}
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_BODY=$(echo "$PR_BODY_B64" | base64 -d)
          ISSUE_NUM=$(echo "$PR_BODY" | grep -oP '(Resolves|Fixes|Closes|Fix)\s*#\K\d+' | head -1 || echo "")
          echo "issue_number=$ISSUE_NUM" >> $GITHUB_OUTPUT

          if [ -n "$ISSUE_NUM" ]; then
            echo "Found linked issue: #$ISSUE_NUM"
            ISSUE_JSON=$(gh api repos/${{ github.repository }}/issues/$ISSUE_NUM 2>/dev/null || echo "{}")
            ISSUE_TITLE=$(echo "$ISSUE_JSON" | jq -r '.title // ""')
            ISSUE_BODY=$(echo "$ISSUE_JSON" | jq -r '.body // ""')
            echo "issue_title=$ISSUE_TITLE" >> $GITHUB_OUTPUT
            echo "issue_body_b64=$(echo "$ISSUE_BODY" | base64 -w0)" >> $GITHUB_OUTPUT
          else
            echo "No linked issue found in PR body"
            echo "issue_title=" >> $GITHUB_OUTPUT
            echo "issue_body_b64=" >> $GITHUB_OUTPUT
          fi

      - name: Count fix attempts from PR labels
        if: steps.get-pr.outputs.pr_number != ''
        id: count-attempts
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ steps.get-pr.outputs.pr_number }}"
          LABELS=$(gh api repos/${{ github.repository }}/issues/$PR_NUMBER/labels --jq '.[].name' 2>/dev/null || echo "")
          COUNT=0
          for label in $LABELS; do
            if [[ "$label" =~ ^claude-fix-attempt-[0-9]+$ ]]; then
              NUM=$(echo "$label" | grep -oP '\d+$')
              if [ "$NUM" -gt "$COUNT" ]; then COUNT=$NUM; fi
            fi
          done
          echo "Current fix attempt count: $COUNT"
          echo "count=$COUNT" >> $GITHUB_OUTPUT

      - name: Check if reviews already passed (or reset on reopen)
        if: steps.get-pr.outputs.pr_number != ''
        id: check-existing-reviews
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ steps.get-pr.outputs.pr_number }}"
          EVENT_NAME="${{ github.event_name }}"

          if [ "$EVENT_NAME" = "pull_request" ] && [ "${{ github.event.action }}" = "reopened" ]; then
            echo "PR was reopened - removing agent-reviews-passed label to allow re-review"
            gh pr edit $PR_NUMBER --remove-label "agent-reviews-passed" --repo ${{ github.repository }} 2>/dev/null || true
            echo "already_passed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          LABELS=$(gh api repos/${{ github.repository }}/issues/$PR_NUMBER/labels --jq '.[].name' 2>/dev/null || echo "")
          if echo "$LABELS" | grep -q "^agent-reviews-passed$"; then
            echo "Agent reviews already passed for this PR - skipping review cycle"
            echo "already_passed=true" >> $GITHUB_OUTPUT
          else
            echo "already_passed=false" >> $GITHUB_OUTPUT
          fi

      - name: Check PR author authorization
        if: steps.get-pr.outputs.pr_number != ''
        id: check-author-auth
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ steps.get-pr.outputs.pr_number }}"
          PR_DATA=$(gh api repos/${{ github.repository }}/pulls/$PR_NUMBER)
          AUTHOR_ASSOC=$(echo "$PR_DATA" | jq -r '.author_association')
          AUTHOR_LOGIN=$(echo "$PR_DATA" | jq -r '.user.login')
          HEAD_REPO=$(echo "$PR_DATA" | jq -r '.head.repo.full_name')
          BASE_REPO=$(echo "$PR_DATA" | jq -r '.base.repo.full_name')

          echo "PR Author: $AUTHOR_LOGIN (association: $AUTHOR_ASSOC)"

          case "$AUTHOR_ASSOC" in
            OWNER|MEMBER|COLLABORATOR)
              echo "Authorized: $AUTHOR_LOGIN is a $AUTHOR_ASSOC"
              echo "authorized=true" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Not authorized: $AUTHOR_LOGIN is a $AUTHOR_ASSOC"
              echo "authorized=false" >> $GITHUB_OUTPUT
              gh pr comment $PR_NUMBER --body "## Claude Code Review Skipped

          This PR was opened by an external contributor ($AUTHOR_LOGIN with association: $AUTHOR_ASSOC).

          For security reasons, Claude Code reviews are only enabled for repository collaborators, members, and owners.

          A repository maintainer will review this PR manually.

          ---
          This is an automated security notice." --repo ${{ github.repository }} 2>/dev/null || true
              ;;
          esac

      - name: Classify PR files
        if: steps.get-pr.outputs.pr_number != ''
        id: classify-files
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ steps.get-pr.outputs.pr_number }}"
          FILES=$(gh pr diff $PR_NUMBER --name-only --repo ${{ github.repository }})
          echo "Changed files:"
          echo "$FILES"
          CONFIG_ONLY="true"
          HAS_RUST_CODE="false"
          HAS_DOCS="false"
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            if [[ "$file" == *.rs ]]; then HAS_RUST_CODE="true"; fi
            if [[ "$file" == *.md ]] || [[ "$file" == docs/* ]]; then HAS_DOCS="true"; fi
            if [[ "$file" == *.rs ]] || [[ "$file" == Cargo.toml ]] || [[ "$file" == Cargo.lock ]] || [[ "$file" == Dockerfile ]] || [[ "$file" == docker-compose.yml ]] || [[ "$file" == *.md ]]; then
              CONFIG_ONLY="false"
            fi
          done <<< "$FILES"
          echo "Classification: config_only=$CONFIG_ONLY has_rust_code=$HAS_RUST_CODE has_docs=$HAS_DOCS"
          echo "config_only=$CONFIG_ONLY" >> $GITHUB_OUTPUT
          echo "has_rust_code=$HAS_RUST_CODE" >> $GITHUB_OUTPUT
          echo "has_docs=$HAS_DOCS" >> $GITHUB_OUTPUT

  # ─── Devcontainer Build ────────────────────────────────────────────────
  # SECURITY: Always builds from main branch, NEVER from PR branches

  build-devcontainer:
    runs-on: ubuntu-latest
    needs: get-context
    if: |
      needs.get-context.outputs.pr_number != '' &&
      needs.get-context.outputs.is_draft != 'true' &&
      needs.get-context.outputs.reviews_already_passed != 'true' &&
      needs.get-context.outputs.author_authorized == 'true'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout main branch (security measure)
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push devcontainer
        uses: devcontainers/ci@v0.3
        with:
          imageName: ${{ env.DEVCONTAINER_IMAGE }}
          cacheFrom: ${{ env.DEVCONTAINER_IMAGE }}
          push: always

  # ─── Fix Test Failures (retry loop, max 3 attempts) ───────────────────

  fix-test-failures:
    needs: [get-context, build-devcontainer]
    if: |
      needs.get-context.outputs.pr_number != '' &&
      needs.get-context.outputs.is_draft != 'true' &&
      needs.get-context.outputs.reviews_already_passed != 'true' &&
      needs.get-context.outputs.author_authorized == 'true' &&
      needs.get-context.outputs.tests_passed == 'false' &&
      needs.get-context.outputs.fix_attempts < 3 &&
      needs.get-context.outputs.has_rust_code == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      packages: read
      actions: write
      statuses: write

    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.get-context.outputs.head_ref }}
          repository: ${{ needs.get-context.outputs.head_repo }}
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Increment fix attempt counter
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ needs.get-context.outputs.pr_number }}"
          NEXT_ATTEMPT=$((${{ needs.get-context.outputs.fix_attempts }} + 1))
          gh label create "claude-fix-attempt-$NEXT_ATTEMPT" --color "ff9500" --description "Claude fix attempt $NEXT_ATTEMPT" --repo ${{ github.repository }} 2>/dev/null || true
          gh pr edit $PR_NUMBER --add-label "claude-fix-attempt-$NEXT_ATTEMPT" --repo ${{ github.repository }}

      - name: Create mount directories for devcontainer
        run: mkdir -p ~/.config/gh ~/.claude ~/.azure

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run Claude to fix test failures
        id: claude-fix
        uses: devcontainers/ci@v0.3
        with:
          imageName: ${{ env.DEVCONTAINER_IMAGE }}
          cacheFrom: ${{ env.DEVCONTAINER_IMAGE }}
          push: never
          env: |
            CLAUDE_CODE_OAUTH_TOKEN=${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
            GH_TOKEN=${{ secrets.WORKFLOW_PAT }}
            PR_NUMBER=${{ needs.get-context.outputs.pr_number }}
            PR_TITLE=${{ needs.get-context.outputs.pr_title }}
            PR_BODY_B64=${{ needs.get-context.outputs.pr_body_b64 }}
            ISSUE_NUMBER=${{ needs.get-context.outputs.issue_number }}
            ISSUE_TITLE=${{ needs.get-context.outputs.issue_title }}
            ISSUE_BODY_B64=${{ needs.get-context.outputs.issue_body_b64 }}
            RUN_ID=${{ needs.get-context.outputs.run_id }}
            ATTEMPT_NUM=${{ needs.get-context.outputs.fix_attempts }}
            REPO=${{ github.repository }}
            TRIGGERING_SHA=${{ needs.get-context.outputs.triggering_sha }}
            HEAD_REF=${{ needs.get-context.outputs.head_ref }}
          runCmd: |
            ATTEMPT=$((ATTEMPT_NUM + 1))
            PR_BODY=$(echo "$PR_BODY_B64" | base64 -d 2>/dev/null || echo "")
            ISSUE_BODY=$(echo "$ISSUE_BODY_B64" | base64 -d 2>/dev/null || echo "")

            claude --print \
              --verbose \
              --output-format stream-json \
              --model sonnet \
              --dangerously-skip-permissions \
              --max-turns 200 \
              "You are fixing CI test failures for PR #${PR_NUMBER} in ${REPO}.
            This is fix attempt ${ATTEMPT} of 3.

            CRITICAL: BEFORE PUSHING ANY CHANGES, check if the PR author has pushed newer commits:
              git fetch origin ${HEAD_REF}
              CURRENT_HEAD=\$(git rev-parse origin/${HEAD_REF})
              if [ \"\$CURRENT_HEAD\" != \"${TRIGGERING_SHA}\" ]; then
                echo 'Author has pushed newer commits - attempting to merge'
                git stash 2>/dev/null || true
                if git pull --rebase origin ${HEAD_REF}; then
                  git stash pop 2>/dev/null || true
                else
                  git rebase --abort 2>/dev/null || true
                  git stash pop 2>/dev/null || true
                  gh pr comment ${PR_NUMBER} --body '## Fix Attempt ${ATTEMPT}/3 - Aborted

            Detected newer commits. Attempted merge but encountered conflicts. Skipping.'
                  exit 0
                fi
              fi

            ORIGINAL ISSUE (if applicable):
            Issue #${ISSUE_NUMBER}: ${ISSUE_TITLE}
            ${ISSUE_BODY}

            PR DESCRIPTION: ${PR_TITLE}
            ${PR_BODY}

            The tests failed (run ID: ${RUN_ID}). Your task:
            1. Check logs: gh run view ${RUN_ID} --log-failed
            2. Identify root cause
            3. Fix the issues
            4. Run \`cargo test\` / \`markdownlint '**/*.md' --config .markdownlint.json\` to verify
            5. Commit and push

            RULES:
            - If Cargo.toml exists: \`cargo test\`, \`cargo fmt --check\`, \`cargo clippy -- -D warnings\`
            - \`markdownlint '**/*.md' --config .markdownlint.json\` for markdown
            - Never use \`git push --no-verify\`
            - If attempt 2+, try a different approach

            After pushing:
            gh pr comment ${PR_NUMBER} --body '## Fix Attempt ${ATTEMPT}/3

            [Describe what you found and fixed]

            Pushed fix - triggering new test run.'" < /dev/null 2>&1 | tee /workspaces/confidential-computing-tsa/fix-failures-output.jsonl

      - name: Trigger PR Tests and reviews after fix
        if: success()
        env:
          GH_TOKEN: ${{ secrets.WORKFLOW_PAT }}
          FIX_ATTEMPTS: ${{ needs.get-context.outputs.fix_attempts }}
        run: |
          git fetch origin ${{ needs.get-context.outputs.head_ref }}
          CURRENT_HEAD=$(git rev-parse origin/${{ needs.get-context.outputs.head_ref }})
          TRIGGERING_SHA="${{ needs.get-context.outputs.triggering_sha }}"

          if [ "$CURRENT_HEAD" != "$TRIGGERING_SHA" ]; then
            echo "Fix was pushed - triggering PR Tests..."
            gh workflow run "PR Tests" --ref "${{ needs.get-context.outputs.head_ref }}" --repo ${{ github.repository }}
            sleep 10

            RUN_ID=$(gh run list --workflow="pr-tests.yml" --branch="${{ needs.get-context.outputs.head_ref }}" --limit=1 --json databaseId --jq '.[0].databaseId')
            echo "Found PR Tests run: $RUN_ID"

            MAX_WAIT=900; ELAPSED=0; POLL_INTERVAL=30
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              STATUS=$(gh run view $RUN_ID --json status,conclusion --jq '.status')
              if [ "$STATUS" = "completed" ]; then
                CONCLUSION=$(gh run view $RUN_ID --json conclusion --jq '.conclusion')
                echo "PR Tests completed: $CONCLUSION"
                break
              fi
              echo "Waiting... (${ELAPSED}s)"
              sleep $POLL_INTERVAL
              ELAPSED=$((ELAPSED + POLL_INTERVAL))
            done

            if [ $ELAPSED -ge $MAX_WAIT ]; then echo "Timed out"; exit 0; fi

            if [ "$CONCLUSION" = "success" ]; then
              gh api repos/${{ github.repository }}/statuses/$CURRENT_HEAD \
                -f state="success" \
                -f target_url="https://github.com/${{ github.repository }}/actions/runs/$RUN_ID" \
                -f description="All required tests passed (via automated fix)" \
                -f context="All Required Tests"

              gh workflow run "Claude Code Review" --ref "main" --repo ${{ github.repository }} \
                -f head_ref="${{ needs.get-context.outputs.head_ref }}" \
                -f head_repo="${{ needs.get-context.outputs.head_repo }}" \
                -f pr_number="${{ needs.get-context.outputs.pr_number }}" \
                -f tests_passed="true" -f run_id="$RUN_ID"
            else
              NEXT_ATTEMPT=$((FIX_ATTEMPTS + 1))
              if [ "$NEXT_ATTEMPT" -lt 3 ]; then
                gh workflow run "Claude Code Review" --ref "main" --repo ${{ github.repository }} \
                  -f head_ref="${{ needs.get-context.outputs.head_ref }}" \
                  -f head_repo="${{ needs.get-context.outputs.head_repo }}" \
                  -f pr_number="${{ needs.get-context.outputs.pr_number }}" \
                  -f tests_passed="false" -f run_id="$RUN_ID"
              else
                gh pr comment ${{ needs.get-context.outputs.pr_number }} --body "## Automated Fix Failed

          All 3 automated fix attempts were unsuccessful. Human intervention is required.

          **Recent Test Run:** https://github.com/${{ github.repository }}/actions/runs/$RUN_ID

          Generated by Claude Code Review workflow"
              fi
            fi
          else
            echo "No new commits pushed"
          fi

      - name: Upload fix attempt output
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: fix-failures-output-attempt-${{ needs.get-context.outputs.fix_attempts }}
          path: fix-failures-output.jsonl
          retention-days: 7

  # ─── Agent Team Review (replaces 7 sequential review jobs) ─────────────
  # Uses Claude Code Agent Teams to run all reviewers in parallel within
  # a single session. The team lead creates reviewer teammates, coordinates
  # their work, and synthesizes the merge decision.

  agent-team-review:
    needs: [get-context, build-devcontainer]
    if: |
      needs.get-context.outputs.pr_number != '' &&
      needs.get-context.outputs.is_draft != 'true' &&
      needs.get-context.outputs.reviews_already_passed != 'true' &&
      needs.get-context.outputs.author_authorized == 'true' &&
      needs.get-context.outputs.tests_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      decision: ${{ steps.parse-decision.outputs.decision }}
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      packages: read

    steps:
      - name: Verify tests passed on current commit
        id: verify-tests
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          HEAD_SHA=$(gh api repos/${{ github.repository }}/pulls/${{ needs.get-context.outputs.pr_number }} --jq '.head.sha')
          MAX_ATTEMPTS=40; ATTEMPT=1
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            STATUS=$(gh api repos/${{ github.repository }}/commits/$HEAD_SHA/check-runs --jq '[.check_runs[] | select(.name == "All Required Tests")] | sort_by(.completed_at) | last | .conclusion' 2>/dev/null || echo "")
            if [ "$STATUS" = "success" ]; then echo "verified=true" >> $GITHUB_OUTPUT; exit 0; fi
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then sleep 10; fi
            ATTEMPT=$((ATTEMPT + 1))
          done
          echo "verified=false" >> $GITHUB_OUTPUT

      - name: Checkout PR branch
        if: steps.verify-tests.outputs.verified == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.get-context.outputs.head_ref }}
          repository: ${{ needs.get-context.outputs.head_repo }}
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Pull latest changes
        if: steps.verify-tests.outputs.verified == 'true'
        run: git pull origin ${{ needs.get-context.outputs.head_ref }} || true

      - name: Create mount directories for devcontainer
        if: steps.verify-tests.outputs.verified == 'true'
        run: mkdir -p ~/.config/gh ~/.claude ~/.azure

      - name: Log in to GHCR
        if: steps.verify-tests.outputs.verified == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Run agent team review in devcontainer
        if: steps.verify-tests.outputs.verified == 'true'
        uses: devcontainers/ci@v0.3
        with:
          imageName: ${{ env.DEVCONTAINER_IMAGE }}
          cacheFrom: ${{ env.DEVCONTAINER_IMAGE }}
          push: never
          env: |
            CLAUDE_CODE_OAUTH_TOKEN=${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
            GH_TOKEN=${{ secrets.WORKFLOW_PAT }}
            CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1
            PR_NUMBER=${{ needs.get-context.outputs.pr_number }}
            PR_TITLE=${{ needs.get-context.outputs.pr_title }}
            PR_BODY_B64=${{ needs.get-context.outputs.pr_body_b64 }}
            ISSUE_NUMBER=${{ needs.get-context.outputs.issue_number }}
            ISSUE_TITLE=${{ needs.get-context.outputs.issue_title }}
            ISSUE_BODY_B64=${{ needs.get-context.outputs.issue_body_b64 }}
            HEAD_REF=${{ needs.get-context.outputs.head_ref }}
            REPO=${{ github.repository }}
            HAS_RUST_CODE=${{ needs.get-context.outputs.has_rust_code }}
            HAS_DOCS=${{ needs.get-context.outputs.has_docs }}
            CONFIG_ONLY=${{ needs.get-context.outputs.config_only }}
          runCmd: |
            PR_BODY=$(echo "$PR_BODY_B64" | base64 -d 2>/dev/null || echo "")
            ISSUE_BODY=$(echo "$ISSUE_BODY_B64" | base64 -d 2>/dev/null || echo "")

            ISSUE_COMMENTS=""
            if [ -n "$ISSUE_NUMBER" ]; then
              ISSUE_COMMENTS=$(gh api "repos/${REPO}/issues/${ISSUE_NUMBER}/comments" --jq '.[] | "---\n**\(.user.login)** commented at \(.created_at):\n\(.body)\n"' 2>/dev/null | head -c 50000 || echo "")
            fi

            claude --print \
              --verbose \
              --output-format stream-json \
              --model opus \
              --dangerously-skip-permissions \
              --max-turns 600 \
              --teammate-mode in-process \
              "You are the REVIEW TEAM LEAD for PR #${PR_NUMBER} in ${REPO}.

            Your job is to coordinate a team of specialist reviewers, then synthesize their
            findings into a final merge decision. Use Claude Code Agent Teams to create
            reviewer teammates that work IN PARALLEL.

            **PR CONTEXT:**
            PR Title: ${PR_TITLE}
            PR Description: ${PR_BODY}
            Linked Issue #${ISSUE_NUMBER}: ${ISSUE_TITLE}
            Issue Description: ${ISSUE_BODY}
            Issue Comments: ${ISSUE_COMMENTS}
            Has Rust Code: ${HAS_RUST_CODE}
            Has Docs: ${HAS_DOCS}
            Config Only: ${CONFIG_ONLY}

            **STEP 1: CREATE THE REVIEW TEAM**

            Create an agent team named 'pr-review-${PR_NUMBER}' with the following teammates.
            Each teammate should use Sonnet model. Give each a focused, specific task.

            Skip teammates whose review category is not relevant (e.g., skip test-reviewer
            if no Rust code, skip crypto-reviewer if config_only=true).

            TEAMMATE 1 - Design Reviewer:
            Review PR #${PR_NUMBER}. Validate that this PR correctly implements the intent
            described in the linked issue. Evaluate design decisions: architecture fit,
            trade-offs, edge cases, scalability, maintainability. Reference
            docs/01-architecture-overview.md for context. Run: git diff origin/main...HEAD.
            Write your findings to /tmp/review-design.md with sections: Intent Validation,
            Design Analysis (Strengths, Concerns, Suggestions), Conclusion
            (Approved/Approved with reservations/Needs revision).

            TEAMMATE 2 - Code & Content Reviewer:
            Review PR #${PR_NUMBER}. Focus on code quality and content accuracy. Only report
            actionable issues. If Rust code: check error handling, memory safety, thread
            safety, unsafe blocks. If docs: check technical accuracy, cross-doc consistency,
            standards references. Run cargo test/fmt/clippy if Rust code present. Run
            markdownlint if docs present. For HIGH SEVERITY issues, fix directly, commit,
            and push (rebase first: git pull --rebase origin ${HEAD_REF}). Write findings
            to /tmp/review-code-content.md with sections: Issues Found, Fixes Applied,
            Conclusion (Approved/Needs changes/Blocking issues).

            TEAMMATE 3 - Test Reviewer (SKIP if has_rust_code=false):
            Review PR #${PR_NUMBER}. Check for missing tests, proper #[cfg(test)] usage,
            async tests with #[tokio::test], missing edge case coverage, timing-dependent
            tests. Run cargo test to verify. For HIGH SEVERITY issues, fix directly and
            push. Write findings to /tmp/review-test.md with sections: Issues Found,
            Fixes Applied, Conclusion.

            TEAMMATE 4 - Cryptographic Design Reviewer (SKIP if config_only=true):
            Review PR #${PR_NUMBER}. Validate crypto claims against
            docs/03-quantum-safe-threshold-crypto.md, docs/06-rfc3161-compliance.md,
            docs/07-threat-model.md. Check for incorrect crypto claims, threshold parameter
            inconsistencies, protocol errors, PQ algorithm misuse, key management issues,
            timing side-channels, missing security assumptions. For HIGH SEVERITY errors,
            fix and push. Write findings to /tmp/review-crypto.md with sections: Issues
            Found, Fixes Applied, Conclusion.

            TEAMMATE 5 - Documentation Reviewer:
            Review PR #${PR_NUMBER}. Check if docs need updating for the changes made.
            Only flag docs that MUST be updated. If updates needed, make changes directly
            and push (rebase first). Write findings to /tmp/review-docs.md with sections:
            Updates Required, Updates Applied, Conclusion.

            TEAMMATE 6 - External Reviewability Reviewer (SKIP if config_only=true):
            Review PR #${PR_NUMBER}. Evaluate whether changes preserve the invariant: a
            relying party must verify CC-TSA security without trusting the operator.
            Check 6 invariants: no org process trust for security, attestation measurement
            binding, key material ephemerality, external verifiability, structural prevention
            vs detection, software immutability during key lifetime. Read docs/07-threat-model.md
            and docs/01-architecture-overview.md. This is READ-ONLY - do not push changes.
            Write findings to /tmp/review-standards.md.

            TEAMMATE 7 - RFC Standards Reviewer (SKIP if config_only=true):
            Review PR #${PR_NUMBER}. Validate RFC 3161, NIST SP 800-208, AMD SEV-SNP
            compliance. Check timestamp protocol format, PQ algorithm parameters, attestation
            report format, ASN.1 encoding. Read docs/06-rfc3161-compliance.md and
            docs/02-confidential-computing-and-time.md. This is READ-ONLY - do not push.
            Write findings to /tmp/review-rfc-standards.md.

            **STEP 2: WAIT FOR ALL TEAMMATES TO COMPLETE**

            Monitor the team. All teammates should work in parallel. Wait until every
            teammate has completed their task and written their review file.

            **STEP 3: SYNTHESIZE AND POST RESULTS**

            Once all teammates are done:

            1. Read all review files from /tmp/review-*.md
            2. Post INDIVIDUAL review comments for each reviewer (one gh pr comment per
               reviewer, using the same format as the review files). This preserves the
               detailed per-specialist feedback that has been valuable historically.
            3. Check for merge conflicts: git fetch origin main && git merge-base --is-ancestor origin/main HEAD || echo CONFLICTS
            4. If conflicts exist AND the PR should be merged, resolve them.
            5. Make your GO/NO-GO decision based on all reviews:
               - GO: All reviews passed or had only minor non-blocking issues
               - NO-GO: Any review found blocking issues, unresolvable conflicts, or tests failing
            6. Post the final merge decision comment:

            gh pr comment ${PR_NUMBER} --body '## Merge Decision

            **Decision: [GO | NO-GO]**

            ### Review Summary
            | Agent | Status |
            |-------|--------|
            | Design Review | [Passed/Failed/Skipped] |
            | Code & Content Review | [Passed/Failed/Skipped] |
            | Test Review | [Passed/Failed/Skipped] |
            | Cryptographic Design Review | [Passed/Failed/Skipped] |
            | Documentation Review | [Passed/Failed/Skipped] |
            | External Reviewability Review | [Passed/Failed/Skipped] |
            | RFC Standards Review | [Passed/Failed/Skipped] |

            [If GO: Ready for merge to main.]
            [If NO-GO: List specific blockers.]

            ---
            Reviews conducted by Claude Code Agent Team (parallel execution)
            Generated by Claude Code Review workflow'" < /dev/null 2>&1 | tee /workspaces/confidential-computing-tsa/agent-team-review-output.jsonl

      - name: Upload agent team review output
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: agent-team-review-output
          path: agent-team-review-output.jsonl
          retention-days: 7

      - name: Parse merge decision from PR comments
        id: parse-decision
        if: always() && steps.verify-tests.outputs.verified == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ needs.get-context.outputs.pr_number }}
        run: |
          COMMENTS=$(gh api repos/${{ github.repository }}/issues/${PR_NUMBER}/comments \
            --jq '[.[] | select(.body | contains("## Merge Decision"))] | last')

          if [ -z "$COMMENTS" ] || [ "$COMMENTS" = "null" ]; then
            echo "decision=NO-GO" >> $GITHUB_OUTPUT; exit 0
          fi

          COMMENT_BODY=$(echo "$COMMENTS" | jq -r '.body')
          if echo "$COMMENT_BODY" | grep -qE "Decision:.*GO" && ! echo "$COMMENT_BODY" | grep -qE "Decision:.*NO-GO"; then
            echo "decision=GO" >> $GITHUB_OUTPUT
          else
            echo "decision=NO-GO" >> $GITHUB_OUTPUT
          fi

  # ─── Aggregator (use as required check for branch protection) ─────────

  all-reviews-passed:
    name: All Required Agent Reviews
    runs-on: ubuntu-latest
    needs: [get-context, build-devcontainer, fix-test-failures, agent-team-review]
    if: always()
    permissions:
      statuses: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check review results
        id: check-results
        run: |
          check_result() {
            local result=$1
            [[ "$result" == "success" || "$result" == "skipped" ]]
          }

          failed=false

          if [ -z "${{ needs.get-context.outputs.pr_number }}" ]; then
            echo "No PR found - skipping"; exit 0
          fi

          if [ "${{ needs.get-context.outputs.reviews_already_passed }}" = "true" ]; then
            echo "Reviews already passed"; echo "skipped_with_success=true" >> $GITHUB_OUTPUT; exit 0
          fi

          if [ "${{ needs.get-context.outputs.is_draft }}" = "true" ]; then
            echo "Draft PR - skipping"; echo "is_draft=true" >> $GITHUB_OUTPUT; exit 0
          fi

          if [ "${{ needs.get-context.outputs.author_authorized }}" != "true" ]; then
            echo "Unauthorized author"; echo "unauthorized=true" >> $GITHUB_OUTPUT; exit 0
          fi

          TESTS_PASSED="${{ needs.get-context.outputs.tests_passed }}"
          FIX_ATTEMPTS="${{ needs.get-context.outputs.fix_attempts }}"

          if [ "$TESTS_PASSED" = "false" ] && [ "$FIX_ATTEMPTS" -lt 3 ]; then
            if ! check_result "${{ needs.fix-test-failures.result }}"; then
              failed=true
            else
              exit 0
            fi
          fi

          if [ "$TESTS_PASSED" = "true" ]; then
            # Check the agent team review job result
            if ! check_result "${{ needs.agent-team-review.result }}"; then
              echo "Agent team review: ${{ needs.agent-team-review.result }}"
              failed=true
            fi

            # Check the merge decision
            MERGE_DECISION="${{ needs.agent-team-review.outputs.decision }}"
            if [ "$MERGE_DECISION" = "NO-GO" ] || [ -z "$MERGE_DECISION" ]; then
              echo "Merge decision: ${MERGE_DECISION:-empty}"
              echo "merge_decision_nogo=true" >> $GITHUB_OUTPUT
              failed=true
            fi
          fi

          if [ "$TESTS_PASSED" = "false" ] && [ "$FIX_ATTEMPTS" -ge 3 ]; then
            echo "Max fix attempts reached"; failed=true
          fi

          if [ "$failed" = true ]; then echo "Some checks failed"; exit 1; fi

          echo "All agent reviews passed - PR is ready for merge"
          echo "should_label=true" >> $GITHUB_OUTPUT

      - name: Create commit status for reviews
        if: |
          needs.get-context.outputs.pr_number != '' &&
          (needs.get-context.outputs.tests_passed == 'true' || steps.check-results.outputs.skipped_with_success == 'true')
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ needs.get-context.outputs.pr_number }}"
          HEAD_SHA=$(gh api repos/${{ github.repository }}/pulls/$PR_NUMBER --jq '.head.sha')

          if [ "${{ steps.check-results.outputs.skipped_with_success }}" = "true" ]; then
            DESCRIPTION="Agent reviews already passed (skipped re-review)"
          else
            DESCRIPTION="All agent reviews completed successfully"
          fi

          gh api repos/${{ github.repository }}/statuses/$HEAD_SHA \
            -f state="success" \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            -f description="$DESCRIPTION" \
            -f context="All Required Agent Reviews"

      - name: Add agent-reviews-passed label
        if: |
          steps.check-results.outputs.should_label == 'true' &&
          needs.get-context.outputs.pr_number != ''
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ needs.get-context.outputs.pr_number }}"
          gh label create "agent-reviews-passed" --color "0e8a16" --description "All agent reviews have passed" --repo ${{ github.repository }} 2>/dev/null || true
          gh pr edit $PR_NUMBER --add-label "agent-reviews-passed" --repo ${{ github.repository }}
          echo "Added 'agent-reviews-passed' label to PR #$PR_NUMBER"

      - name: Post review summary comment
        if: |
          always() &&
          needs.get-context.outputs.pr_number != '' &&
          needs.get-context.outputs.reviews_already_passed != 'true' &&
          needs.get-context.outputs.tests_passed == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ needs.get-context.outputs.pr_number }}
          TESTS_PASSED: ${{ needs.get-context.outputs.tests_passed }}
          FIX_RESULT: ${{ needs.fix-test-failures.result }}
          TEAM_REVIEW_RESULT: ${{ needs.agent-team-review.result }}
          MERGE_DECISION: ${{ needs.agent-team-review.outputs.decision }}
          RUN_ID: ${{ github.run_id }}
          REPO: ${{ github.repository }}
          SERVER_URL: ${{ github.server_url }}
        run: |
          format_result() {
            case "$1" in
              success) echo "Passed" ;; failure) echo "Failed" ;; skipped) echo "Skipped" ;; cancelled) echo "Cancelled" ;; *) echo "$1" ;;
            esac
          }

          COMMENT="## Agent Review Summary\n\n"
          COMMENT+="**Workflow Run:** [#${RUN_ID}](${SERVER_URL}/${REPO}/actions/runs/${RUN_ID})\n\n"

          if [ "$MERGE_DECISION" = "GO" ]; then
            COMMENT+="**Status:** All reviews passed - ready to merge\n\n"
          elif [ "$MERGE_DECISION" = "NO-GO" ]; then
            COMMENT+="**Status:** Blocking issues found - see Merge Decision comment for details\n\n"
          elif [ "${{ steps.check-results.outcome }}" = "success" ]; then
            COMMENT+="**Status:** All reviews completed successfully\n\n"
          else
            COMMENT+="**Status:** Some reviews failed or are incomplete\n\n"
          fi

          COMMENT+="### Agent Team Status\n\n"
          COMMENT+="| Component | Status |\n"
          COMMENT+="|-----------|--------|\n"

          if [ "$TESTS_PASSED" = "false" ]; then
            COMMENT+="| Fix Test Failures | $(format_result "$FIX_RESULT") |\n"
          fi

          if [ "$TESTS_PASSED" = "true" ]; then
            COMMENT+="| Agent Team Review (7 parallel reviewers) | $(format_result "$TEAM_REVIEW_RESULT") |\n"
            COMMENT+="| Merge Decision | ${MERGE_DECISION:-Unknown} |\n"
          fi

          COMMENT+="\n_Individual review comments posted by each teammate above._\n"
          COMMENT+="\n---\n_Reviews conducted by Claude Code Agent Team (parallel execution)._\n"
          COMMENT+="\nGenerated by Claude Code Review workflow"

          echo -e "$COMMENT" | gh pr comment "$PR_NUMBER" --body-file - --repo "$REPO"
